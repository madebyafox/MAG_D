---
title: "Visualization Attitudes via Repertory Grid"
author: "Amy R Fox & Dana Hua"
date: "2024-05-01"
output:
  html_document:
    theme: cosmo
    code_folding: hide
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    toc_depth: 6
  pdf_document:
    toc: yes
    toc_depth: '5'
always_allow_html: yes
font-family: DejaVu Sans
mainfont: DejaVu Sans
editor_options: 
  markdown: 
    wrap: 72
---


# SETUP

### Import Packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#UTILITIES
library(Hmisc) # %nin% operator
library(psych) #describe() & efa
library(tidyverse) #all the things
library(magrittr) #special pipes like %<>%
library(summarytools) #data quality
library(lubridate) #dealing with dates


#VIZ
library(ggformula) #regression syntax viz
library(ggstatsplot) #dummies
library(gghalves) #half boxplots 
library(GGally) #extends ggplot for EDA 
library(corrplot) #sophisticated correlation plots
library(ggeasy) #easy labelling
library(ggh4x) #guides [dual axes]
library(patchwork) #multi-plot layout
library(ggdist) #raincloud plots and other distributionals
library(viridis) #color palettes
library(RColorBrewer) #color palettes
library(plotly) # interactive graphs
library(paletteer) #more palettes
library(interactions) ##easier regression ixn plots.srlsy
library(tidygraph)

#ANALYSIS
library(OpenRepGrid) #https://docs.openrepgrid.org/index.html

#MODELLING
# library(jtools) #Social Science regression utilities
# library(easystats) #modelling helpers
# library(see)
# library(sjPlot)
# library(lme4)
# library(lmerTest) #for CIs in glmer
# # library(mixed) ## utilities for glmers 
# library(jmv) ## jamovi EFA


#STATISTICAL TESTS 
# library(kSamples) #AD K-SAMPLE TEST (for distribution comparison)
# library(rstatix) #FRIEDMAN'S TESTS and effect sizes 

#CONFIG
options(readr.show_col_types = FALSE) #don't show coltypes on read_csv


## IMPORTANT 
# GRAPH_SAVE = TRUE #set to true to generate all the SD graphs and save to folders 
# source("graphing_functions.R") #import graphing palettes and custom functions

```
### Import Data

```{r import-data}

#example grid from package
example <- bell2010
e2 <- mackay1992

## load grid (continuous constructs only) for each participant 
## #importExcel from OpenRepGrid package, creates S4 object 
p4 <-  importExcel(file= "data/participants/continuous/P04_Clean.xlsx")
p5 <-  importExcel(file= "data/participants/continuous/P05_Clean.xlsx")
p8 <-  importExcel(file= "data/participants/continuous/P08_Clean.xlsx")
p9 <-  importExcel(file= "data/participants/continuous/P09_Clean.xlsx")
p10 <- importExcel(file= "data/participants/continuous/P10_Clean.xlsx")
p11 <- importExcel(file= "data/participants/continuous/P11_Clean.xlsx")
p12 <- importExcel(file= "data/participants/continuous/P12_Clean.xlsx")
p13 <- importExcel(file= "data/participants/continuous/P13_Clean.xlsx")
p14 <- importExcel(file= "data/participants/continuous/P14_Clean.xlsx")

```

### Construct SuperGrids 

While a single (repertory) _Grid_ contains data for an individual participant, a _SuperGrid_ contains data for multiple participants. In the case of this study, the same elements were shown to all participants, and thus SuperGrids can be constructed via simple concatenation (i.e. rbind) of individual participant grids. 

```{r supergrids}

## DESIGNER SuperGrid



## RESEARCHER SuperGrid


## MASTER SuperGrid
g_master <- p4+p5+p8+p9+p10+p11+p12+p13+p14

# is.repgrid(g_master) #verify is wff grid

```

# PARTICIPANT-LEVEL

## P04

### WIP EXPLORE

#### Conflicts 
```{r}


## TODO WTAF is measured as 'conflict'? see 
# https://docs.openrepgrid.org/articles/web/measures-conflict.html
#Bell, R. C. (2004). A new approach to measuring inconsistency or conflict in grids. Personal Construct Theory & Practice, 1, 53–59.
#Heider, F. (1946). Attitudes and cognitive organization. Journal of Psychology, 21, 107–112.

indexConflict3(p4)

```

#### Implicative Dilemmas
```{r}
#https://docs.openrepgrid.org/articles/web/measures-implicative.html

# Implicative dilemmas are closely related to the notion of conflict. An implicative dilemma arises when a desired change on one construct is associated with an undesired implication on another construct. E. g. a timid subject may want to become more socially skilled but associates being socially skilled with different negative characteristics (selfish, insensitive etc.). Hence, he may anticipate that becoming less timid will also make him more selfish (cf. Winter, 1982). 

indexDilemma(p4)
## TODO really actually figure out 1. if this is useful and 2. what it is doing. 3. how to define the self (vs) ideal self and align poles

```

### PCA/biplots

```{r biplot-p4}

biplotSimple(p4)
biplot2d(p4)
biplotEsa2d(p4)
biplotSlater2d(p4)
biplotPseudo3d(p4)
# biplot3d(p4)


## TODO! Figure out relationship between biplots and PCA, and precisely what the biplots are depicting

```

```{r pca-p4}
constructPca(p4) 
```

### CONSTRUCT ANALYSIS

```{r describe-constructs-p4}
statsConstructs(p4)

## ARF TODO reformat as df to get ridgeplot of histograms w/ constructs as rows
```




#### Construct Correlations

```{r construct-correlations-p4}
constructCor(g_master)
```


#### Construct Clustering
```{r construct-clustering-p4}

# calculate cluster analysis
# https://docs.openrepgrid.org/articles/web/clustering.html
cluster(p4, along =1, #1=constructs, 2 = elements, 0 = both (default)
        dmethod =  "euclidean",#distance measure TODO evaluate diff options    
        cmethod="ward.D", #agglomeration method TODO evaluate diff options
        align = TRUE, #align b4 clustering? reverses constructs if necessary to yield maximal simmilarity
        cex = 1, lab.cex = 1)

## TODO! Figure out bootstrap clustering
#https://docs.openrepgrid.org/reference/clusterBoot.html

```

### ELEMENT ANALYSIS

#### Describe Elements
```{r describe-elements-p4}

# calculate descriptive statistics 
(descriptives <- statsElements(g_master))
descriptives$element <- rownames(descriptives) #add element name to df


## ARF TODO reform as dfs to get ridgeplot of elements
#visualize distributions
# descriptives %>% ggplot(aes(x=))

```

#### Element Correlations
```{r correlations-elements-p4}

elementCor(g_master)
```



#### Element Clustering
```{r element-clustering-p4}

# calculate cluster analysis
# https://docs.openrepgrid.org/articles/web/clustering.html
cluster(p4, along = 2, #1=constructs, 2 = elements, 0 = both (default)
        dmethod =  "euclidean",#distance measure TODO evaluate diff options    
        cmethod="ward.D", #agglomeration method TODO evaluate diff options
        align = TRUE, #align b4 clustering? reverses constructs if necessary to yield maximal simmilarity
        cex = 1, lab.cex = 1)

```

```{r elements-bertin-b4}

bertinCluster(p4,
              type="rectangle", draw.axis = FALSE)

```



# GROUP LEVEL

## TODO RESEARCHERS
## TODO DESIGNERS 

## ALL PARTICIPANTS

### PCA/BIPLOTS


```{r biplot-master}

biplotSimple(g_master)
biplot2d(g_master)
biplotEsa2d(g_master)
biplotSlater2d(g_master)
biplotPseudo3d(g_master)
# biplot3d(g_master)


## TODO! Figure out relationship between biplots and PCA, and precisely what the biplots are depicting

```

### CONSTRUCT ANALYSIS

```{r describe-master-constructs}
statsConstructs(g_master)

## ARF TODO reformat as df to get ridgeplot of histograms w/ constructs as rows
```




#### Construct Correlations

```{r master-construct-correlations}
constructCor(g_master)
```
### ELEMENT ANALYSIS

#### Describe Elements
```{r describe-master-elements}

# calculate descriptive statistics 
(descriptives <- statsElements(g_master))
descriptives$element <- rownames(descriptives) #add element name to df


## ARF TODO reform as dfs to get ridgeplot of elements
#visualize distributions
# descriptives %>% ggplot(aes(x=))

```

#### Element Correlations
```{r master-correlations-elements}

elementCor(g_master)
```



#### Element Clustering
```{r element-clustering-master}

# calculate cluster analysis
# https://docs.openrepgrid.org/articles/web/clustering.html
cluster(g_master, along = 1, #1=constructs, 2 = elements, 0 = both (default)
        dmethod =  "euclidean",#distance measure TODO evaluate diff options    
        cmethod="ward.D", #agglomeration method TODO evaluate diff options
        align = TRUE, #align b4 clustering? reverses constructs if necessary to yield maximal simmilarity
        cex = 1, lab.cex = 1)


distanceHartmann(g_master) 
```

```{r elements-bertin-master}

bertinCluster(g_master,
              type="rectangle", draw.axis = FALSE)

```

```